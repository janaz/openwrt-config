diff --git a/target/linux/kirkwood/files/arch/arm/mach-kirkwood/iconnect-setup.c b/target/linux/kirkwood/files/arch/arm/mach-kirkwood/iconnect-setup.c
new file mode 100644
index 0000000..1915caa
--- /dev/null
+++ b/target/linux/kirkwood/files/arch/arm/mach-kirkwood/iconnect-setup.c
@@ -0,0 +1,188 @@
+/*
+ * arch/arm/mach-kirkwood/iconnect-setup.c
+ *
+ * Iomega iConnect Wireless
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition iconnect_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_1M + SZ_2M
+	}, {
+		.name = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M,
+	}, {
+		.name = "data",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data iconnect_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
+};
+
+static struct gpio_led iconnect_led_pins[] = {
+	{
+		.name			= "iconnect:blue:power",
+		.default_trigger	= "default-on",
+		.gpio			= 42,
+	},
+	{
+		.name			= "iconnect:red:power",
+		.gpio			= 43,
+	},
+	{
+		.name			= "iconnect:blue:usb1",
+		.gpio			= 44,
+	},
+	{
+		.name			= "iconnect:blue:usb2",
+		.gpio			= 45,
+	},
+	{
+		.name			= "iconnect:blue:usb3",
+		.gpio			= 46,
+	},
+	{
+		.name			= "iconnect:blue:usb4",
+		.gpio			= 47,
+	},
+	{
+		.name			= "iconnect:blue:otb",
+		.gpio			= 48,
+	},
+};
+
+static struct gpio_led_platform_data iconnect_led_data = {
+	.leds		= iconnect_led_pins,
+	.num_leds	= ARRAY_SIZE(iconnect_led_pins),
+};
+
+static struct platform_device iconnect_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &iconnect_led_data,
+	}
+};
+
+#define ICONNECT_GPIO_KEY_RESET		12
+#define ICONNECT_GPIO_KEY_OTB		35
+
+#define ICONNECT_SW_RESET		0x00
+#define ICONNECT_SW_OTB			0x01
+
+static struct gpio_keys_button iconnect_buttons[] = {
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_RESET,
+		.gpio		= ICONNECT_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		}, 
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_OTB,
+		.gpio		= ICONNECT_GPIO_KEY_OTB,
+		.desc		= "OTB Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		},
+};
+
+static struct gpio_keys_platform_data iconnect_button_data = {
+	.buttons	= iconnect_buttons,
+	.nbuttons	= ARRAY_SIZE(iconnect_buttons),
+};
+
+static struct platform_device iconnect_button_device = {
+	.name	   = "gpio-keys",
+	.id	     = -1,
+	.num_resources	= 0,
+	.dev	    =	{
+					.platform_data  = &iconnect_button_data,
+					},
+};
+
+static unsigned int iconnect_mpp_config[] __initdata = {
+	MPP12_GPIO, /*Input for reset button*/
+	MPP35_GPIO, /*Input for OTB button*/
+	MPP42_GPIO,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	0
+};
+
+static void __init iconnect_init(void)
+{
+	u32 dev, rev;
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(iconnect_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(iconnect_nand_parts), 25);
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&iconnect_ge00_data);
+	kirkwood_pcie_id(&dev, &rev);
+
+	kirkwood_uart0_init();
+	kirkwood_i2c_init();
+
+	platform_device_register(&iconnect_leds);
+	platform_device_register(&iconnect_button_device);
+}
+
+static int __init iconnect_pci_init(void)
+{
+	if (machine_is_iconnect())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(iconnect_pci_init);
+
+
+MACHINE_START(ICONNECT, "Iomega iConnect Wireless")
+	.atag_offset	= 0x100,
+	.init_machine	= iconnect_init,
+	.map_io		= kirkwood_map_io,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff --git a/target/linux/kirkwood/patches/002-mvsdio_delay.patch b/target/linux/kirkwood/patches/002-mvsdio_delay.patch
index ba28853..d9cda32 100644
--- a/target/linux/kirkwood/patches/002-mvsdio_delay.patch
+++ b/target/linux/kirkwood/patches/002-mvsdio_delay.patch
@@ -1,6 +1,6 @@
 --- a/drivers/mmc/core/sd.c
 +++ b/drivers/mmc/core/sd.c
-@@ -332,6 +332,15 @@ int mmc_sd_switch_hs(struct mmc_card *ca
+@@ -389,6 +389,15 @@ int mmc_sd_switch_hs(struct mmc_card *ca
  		return -ENOMEM;
  	}
  
@@ -18,7 +18,7 @@
  		goto out;
 --- a/drivers/mmc/core/core.c
 +++ b/drivers/mmc/core/core.c
-@@ -303,9 +303,9 @@ void mmc_set_data_timeout(struct mmc_dat
+@@ -517,9 +517,9 @@ void mmc_set_data_timeout(struct mmc_dat
  			 * The limit is really 250 ms, but that is
  			 * insufficient for some crappy cards.
  			 */
diff --git a/target/linux/kirkwood/patches/100-boards.patch b/target/linux/kirkwood/patches/100-boards.patch
new file mode 100644
index 0000000..0636da7
--- /dev/null
+++ b/target/linux/kirkwood/patches/100-boards.patch
@@ -0,0 +1,34 @@
+--- a/arch/arm/mach-kirkwood/Makefile
++++ b/arch/arm/mach-kirkwood/Makefile
+@@ -18,5 +18,6 @@ obj-$(CONFIG_MACH_D2NET_V2)		+= d2net_v2
+ obj-$(CONFIG_MACH_NET2BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
+ obj-$(CONFIG_MACH_NET5BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
+ obj-$(CONFIG_MACH_T5325)		+= t5325-setup.o
++obj-$(CONFIG_MACH_ICONNECT)		+= iconnect-setup.o
+ 
+ obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
+--- a/arch/arm/mach-kirkwood/Kconfig
++++ b/arch/arm/mach-kirkwood/Kconfig
+@@ -130,6 +130,12 @@ config MACH_T5325
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  HP t5325 Thin Client.
+ 
++config MACH_ICONNECT
++	bool "Iomega iConnect Wireless"
++	help
++	  Say 'Y' here if you want your kernel to support the
++	  Iomega iConnect Wireless.
++
+ endmenu
+ 
+ endif
+--- a/arch/arm/mach-kirkwood/mpp.h
++++ b/arch/arm/mach-kirkwood/mpp.h
+@@ -102,6 +102,7 @@
+ #define MPP11_SATA0_ACTn	MPP( 11, 0x5, 0, 1, 0,   1,   1,   1,   1 )
+ 
+ #define MPP12_GPO		MPP( 12, 0x0, 0, 1, 1,   1,   1,   1,   1 )
++#define MPP12_GPIO		MPP( 12, 0x0, 1, 1, 1,   1,   1,   1,   1 )
+ #define MPP12_SD_CLK		MPP( 12, 0x1, 0, 1, 1,   1,   1,   1,   1 )
+ #define MPP12_AU_SPDIF0		MPP( 12, 0xa, 0, 1, 0,   0,   0,   0,   1 )
+ #define MPP12_SPI_MOSI		MPP( 12, 0xb, 0, 1, 0,   0,   0,   0,   1 )
diff --git a/target/linux/kirkwood/patches/200-iconnect.patch b/target/linux/kirkwood/patches/200-iconnect.patch
deleted file mode 100644
index 30693a8..0000000
--- a/target/linux/kirkwood/patches/200-iconnect.patch
+++ /dev/null
@@ -1,226 +0,0 @@
---- a/arch/arm/mach-kirkwood/Makefile
-+++ b/arch/arm/mach-kirkwood/Makefile
-@@ -8,6 +8,7 @@ obj-$(CONFIG_MACH_SHEEVAPLUG)		+= sheeva
- obj-$(CONFIG_MACH_ESATA_SHEEVAPLUG)	+= sheevaplug-setup.o
- obj-$(CONFIG_MACH_GURUPLUG)		+= guruplug-setup.o
- obj-$(CONFIG_MACH_DOCKSTAR)		+= dockstar-setup.o
-+obj-$(CONFIG_MACH_ICONNECT)		+= iconnect-setup.o
- obj-$(CONFIG_MACH_TS219)		+= ts219-setup.o tsx1x-common.o
- obj-$(CONFIG_MACH_TS41X)		+= ts41x-setup.o tsx1x-common.o
- obj-$(CONFIG_MACH_OPENRD)		+= openrd-setup.o
---- a/arch/arm/mach-kirkwood/Kconfig
-+++ b/arch/arm/mach-kirkwood/Kconfig
-@@ -130,6 +130,12 @@ config MACH_T5325
- 	  Say 'Y' here if you want your kernel to support the
- 	  HP t5325 Thin Client.
- 
-+config MACH_ICONNECT
-+	bool "Iomega iConnect Wireless"
-+	help
-+	  Say 'Y' here if you want your kernel to support the
-+	  Iomega iConnect Wireless.
-+
- endmenu
- 
- endif
---- a/arch/arm/mach-kirkwood/mpp.h
-+++ b/arch/arm/mach-kirkwood/mpp.h
-@@ -108,6 +108,7 @@
- #define MPP11_SATA0_ACTn	MPP( 11, 0x5, 0, 1, 0,   1,   1,   1,   1 )
- 
- #define MPP12_GPO		MPP( 12, 0x0, 0, 1, 1,   1,   1,   1,   1 )
-+#define MPP12_GPIO		MPP( 12, 0x0, 1, 1, 1,   1,   1,   1,   1 )
- #define MPP12_SD_CLK		MPP( 12, 0x1, 0, 1, 1,   1,   1,   1,   1 )
- #define MPP12_AU_SPDIF0		MPP( 12, 0xa, 0, 1, 0,   0,   0,   0,   1 )
- #define MPP12_SPI_MOSI		MPP( 12, 0xb, 0, 1, 0,   0,   0,   0,   1 )
---- /dev/null
-+++ b/arch/arm/mach-kirkwood/iconnect-setup.c
-@@ -0,0 +1,188 @@
-+/*
-+ * arch/arm/mach-kirkwood/iconnect-setup.c
-+ *
-+ * Iomega iConnect Wireless
-+ *
-+ * This file is licensed under the terms of the GNU General Public
-+ * License version 2.  This program is licensed "as is" without any
-+ * warranty of any kind, whether express or implied.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/init.h>
-+#include <linux/platform_device.h>
-+#include <linux/irq.h>
-+#include <linux/mtd/partitions.h>
-+#include <linux/mv643xx_eth.h>
-+#include <linux/ethtool.h>
-+#include <linux/gpio.h>
-+#include <linux/gpio_keys.h>
-+#include <linux/input.h>
-+#include <linux/leds.h>
-+#include <asm/mach-types.h>
-+#include <asm/mach/arch.h>
-+#include <mach/kirkwood.h>
-+#include "common.h"
-+#include "mpp.h"
-+
-+static struct mtd_partition iconnect_nand_parts[] = {
-+	{
-+		.name = "u-boot",
-+		.offset = 0,
-+		.size = SZ_1M
-+	}, {
-+		.name = "uImage",
-+		.offset = MTDPART_OFS_NXTBLK,
-+		.size = SZ_1M + SZ_2M
-+	}, {
-+		.name = "rootfs",
-+		.offset = MTDPART_OFS_NXTBLK,
-+		.size = SZ_32M,
-+	}, {
-+		.name = "data",
-+		.offset = MTDPART_OFS_NXTBLK,
-+		.size = MTDPART_SIZ_FULL
-+	},
-+};
-+
-+static struct mv643xx_eth_platform_data iconnect_ge00_data = {
-+	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
-+};
-+
-+static struct gpio_led iconnect_led_pins[] = {
-+	{
-+		.name			= "iconnect:blue:power",
-+		.default_trigger	= "default-on",
-+		.gpio			= 42,
-+	},
-+	{
-+		.name			= "iconnect:red:power",
-+		.gpio			= 43,
-+	},
-+	{
-+		.name			= "iconnect:blue:usb1",
-+		.gpio			= 44,
-+	},
-+	{
-+		.name			= "iconnect:blue:usb2",
-+		.gpio			= 45,
-+	},
-+	{
-+		.name			= "iconnect:blue:usb3",
-+		.gpio			= 46,
-+	},
-+	{
-+		.name			= "iconnect:blue:usb4",
-+		.gpio			= 47,
-+	},
-+	{
-+		.name			= "iconnect:blue:otb",
-+		.gpio			= 48,
-+	},
-+};
-+
-+static struct gpio_led_platform_data iconnect_led_data = {
-+	.leds		= iconnect_led_pins,
-+	.num_leds	= ARRAY_SIZE(iconnect_led_pins),
-+};
-+
-+static struct platform_device iconnect_leds = {
-+	.name	= "leds-gpio",
-+	.id	= -1,
-+	.dev	= {
-+		.platform_data	= &iconnect_led_data,
-+	}
-+};
-+
-+#define ICONNECT_GPIO_KEY_RESET		12
-+#define ICONNECT_GPIO_KEY_OTB		35
-+
-+#define ICONNECT_SW_RESET		0x00
-+#define ICONNECT_SW_OTB			0x01
-+
-+static struct gpio_keys_button iconnect_buttons[] = {
-+		{
-+		.type		= EV_SW,
-+		.code		= ICONNECT_SW_RESET,
-+		.gpio		= ICONNECT_GPIO_KEY_RESET,
-+		.desc		= "Reset Button",
-+		.active_low	= 1,
-+		.debounce_interval = 100,
-+		}, 
-+		{
-+		.type		= EV_SW,
-+		.code		= ICONNECT_SW_OTB,
-+		.gpio		= ICONNECT_GPIO_KEY_OTB,
-+		.desc		= "OTB Button",
-+		.active_low	= 1,
-+		.debounce_interval = 100,
-+		},
-+};
-+
-+static struct gpio_keys_platform_data iconnect_button_data = {
-+	.buttons	= iconnect_buttons,
-+	.nbuttons	= ARRAY_SIZE(iconnect_buttons),
-+};
-+
-+static struct platform_device iconnect_button_device = {
-+	.name	   = "gpio-keys",
-+	.id	     = -1,
-+	.num_resources	= 0,
-+	.dev	    =	{
-+					.platform_data  = &iconnect_button_data,
-+					},
-+};
-+
-+static unsigned int iconnect_mpp_config[] __initdata = {
-+	MPP12_GPIO, /*Input for reset button*/
-+	MPP35_GPIO, /*Input for OTB button*/
-+	MPP42_GPIO,
-+	MPP43_GPIO,
-+	MPP44_GPIO,
-+	MPP45_GPIO,
-+	MPP46_GPIO,
-+	MPP47_GPIO,
-+	MPP48_GPIO,
-+	0
-+};
-+
-+static void __init iconnect_init(void)
-+{
-+	u32 dev, rev;
-+
-+	/*
-+	 * Basic setup. Needs to be called early.
-+	 */
-+	kirkwood_init();
-+	kirkwood_mpp_conf(iconnect_mpp_config);
-+
-+	kirkwood_nand_init(ARRAY_AND_SIZE(iconnect_nand_parts), 25);
-+	kirkwood_ehci_init();
-+
-+	kirkwood_ge00_init(&iconnect_ge00_data);
-+	kirkwood_pcie_id(&dev, &rev);
-+
-+	kirkwood_uart0_init();
-+	kirkwood_i2c_init();
-+
-+	platform_device_register(&iconnect_leds);
-+	platform_device_register(&iconnect_button_device);
-+}
-+
-+static int __init iconnect_pci_init(void)
-+{
-+	if (machine_is_iconnect())
-+		kirkwood_pcie_init(KW_PCIE0);
-+
-+	return 0;
-+}
-+subsys_initcall(iconnect_pci_init);
-+
-+
-+MACHINE_START(ICONNECT, "Iomega iConnect Wireless")
-+	.atag_offset	= 0x100,
-+	.init_machine	= iconnect_init,
-+	.map_io		= kirkwood_map_io,
-+	.init_irq	= kirkwood_init_irq,
-+	.timer		= &kirkwood_timer,
-+MACHINE_END
